/*
**	The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
**	1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
**
**	Let us list the factors of the first seven triangle numbers:
**	
**	 1: 1
**	 3: 1,3
**	 6: 1,2,3,6
**	10: 1,2,5,10
**	15: 1,3,5,15
**	21: 1,3,7,21
**	28: 1,2,4,7,14,28
**	We can see that 28 is the first triangle number to have over five divisors.
**	
**	What is the value of the first triangle number to have over five hundred divisors?
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/*
**	I don't know which limit would be reasonable, so be careful not to put a value too
**	high if you want the program to terminate and not be in an infinite loop of overlaps
*/
#define TARGET 500

/*
**	Gaussian formula.
*/
static uint64_t get_nth_triangle_number(uint64_t number)
{
	return number * (number + 1) / 2;
}

static uint32_t sqrt_up(uint64_t number)
{
	uint32_t i = 0;
	while (i * i < number)
	{
		i++;
	}
	return i;
}

/*
**	I check the divisors until the square root rounded up, and then I double it.
**	This gives the good result with far less computation
*/
static uint32_t get_number_of_divisors(uint64_t number)
{
	uint32_t square_root_up = sqrt_up(number);
	uint32_t ret = 0;

	for (uint32_t i = 1; i < square_root_up; i++)
	{
		if ((number % i) == 0)
			ret++;
	}
	return ret * 2;
}

int		main(void)
{
	uint64_t	i = 1;

	while (1)
	{
		uint64_t triangle_nb = get_nth_triangle_number(i);
		if (get_number_of_divisors(triangle_nb) > TARGET)
		{
			printf("Result: %llu\n", triangle_nb);
			break ;
		}
		i++;
	}
	return 0;
}
